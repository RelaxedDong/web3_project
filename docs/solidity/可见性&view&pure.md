https://solidity-cn.readthedocs.io/zh/develop/contracts.html?highlight=external

由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 

函数可以指定为:
默认情况下函数类型为 public。 对于状态变量，不能设置为 external ，默认是 internal
- external 
  - 外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f() 可以）。 当收到大量数据的时候，外部函数有时候会更有效率。
- public 
  - public 函数是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量， 会自动生成一个 getter 函数。
- internal
  - 这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。
- private
  - private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。

# view 关键字
可以将函数声明为 view 类型，这种情况下要保证不修改状态。

下面的语句被认为是修改状态：
- 修改状态变量。
- 产生事件。
- 创建其它合约。
- 使用 selfdestruct。
- 通过调用发送以太币。
- 调用任何没有标记为 view 或者 pure 的函数。
- 使用低级调用。
- 使用包含特定操作码的内联汇编。
# Pure 关键字
函数可以声明为 pure ，在这种情况下，承诺不读取或修改状态。
除了上面解释的状态修改语句列表之外，以下被认为是从状态中读取：

- 读取状态变量。
- 访问 this.balance 或者 <address>.balance。
- 访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。
- 调用任何未标记为 pure 的函数。
- 使用包含某些操作码的内联汇编。

# memory & storage & stack

第一类是 存储storage，贮存了合约声明中所有的变量。 虚拟机会为每份合约分别划出一片独立的 存储storage 区域，并在函数相互调用时持久存在，所以其使用开销非常大。


第二类是 内存 memory，用于暂存数据。
其中存储的内容会在函数被调用（包括外部函数）时擦除，所以其使用开销相对较小。只会在执行的时候存储下
`string类型实际上是字节数组. 是一种特殊的数组，也可以使用追加字符串等操作`

第三类是栈，用于存放小型的局部变量。使用几乎是免费的，但容量有限。

状态变量总是会贮存在 存储storage 中
函数参数默认存放在 内存memory 中
结构、数组或映射类型的局部变量，默认会放在 存储storage 中
除结构、数组及映射类型之外的局部变量，会储存在栈中

